---
title: "rank_harmony"
author: "Sayani Gupta"
date: "24/04/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(readr)
library(gravitas)
library(tidyverse)
```

 1. Suppose $C_1$ and $C_2$ are two cyclic granularities such that $C_1$ maps index set to a set $\{A_1, A_2, A_3, \dots, A_I$\}, and $C_2$ maps index set to a set $\{B_1, B_2, B_3, \dots, B_J$\} and $v$ is the measured variable. Hence for each combination ($A_i$, $B_j$), we have s subset of the time series variable $v_{ij} \subseteq v$, $\forall i = {1, 2, \dots, I}$ and $\forall j = {1, 2, \dots, J}$

 2. There will be $J$ groups corresponding to each level $A_i$ of $C_1$. We compute the pairwise differences in distributions of these $J$ groups. Thus there will be  $k = \binom{J}{2}$ pairwise distances corresponding to each $A_i$. Let $D_1$,...,$D_k$ be these distances and let their maximum be $M_k$.

## Version 1 (suggested by Rob)

 3.1. If the $D_i$ distribution has heavy tails, then under EVT the maximum converges to Frechet and lim $P(M_k / a_k)$ converges to a limiting distribution where $a_k$ = the $(1-\frac{1}{k})$ quantile of the $D_i$ distribution. So normalization could be done  using $M_k / a_k$.

 4.1. For each facet, we have a normalised variable using Step 3.1. We can take the maximum across all facets as the final mesasure. But this maximum is not normalized against the number of facet levels. Or we can take the mean (to be discussed).
 
```{r}
read_rds("data/smart_harmony_ak.rds")
```

```{r}
smart_meter10 %>%
  filter(customer_id %in% c(10017936)) %>%
  prob_plot("day_week",
    "day_month",
    response = "general_supply_kwh",
    plot_type = "quantile",
    symmetric = TRUE,
    quantile_prob = c(0.01, 0.1, 0.25, 0.5, 0.75, 0.9, 0.99)
  ) +
  scale_y_sqrt() +
  #ggtitle(" (b) Area quantile plot faceted by weekend-weekday") +
  ylab("electricity demand [KWh]") + xlab("hours of the day") + ggtitle("") + ylab("")+ 
  theme_minimal()
```


## Version 2 (suggested by Sayani - new)

 3.2. Let $D_{k} \sim N(\mu, \sigma^2)$. Then for $a_k = \mu âˆ’ \sigma\Phi^{-1}(1/k)$ and $b_k = -\sigma/\Phi^{-1}(1/k)$, we have we have $P(\frac{M_k - a_k}{b_k} \leq z) \xrightarrow{} G(z)$, where $G$ is the standard Gumbel distribution. So normalization could be done  using $\frac{M_k - a_k}{b_k}$, where $\Phi^{-1}(1/k)$ could be approximated by $(1 - \frac{1}{k})$ sample quantile and $\mu$ and $\sigma$ by sample mean and standard deviation. 

 4.2. We have been able to normalize for the number of levels of x-axis variable using Step 3.2. Now 
$\forall A_i, \quad i \in \{1, 2, \dots, I\}$, we have a normalised variable each of which follows a standard Gumbel distribution. Now we need to combine these normalised variables across different facets in a way so that the number of facet levels do not play a role. For this we can take the mean, median or any quantiles of these normalised variables. But the median (and any quantiles) of these Gumbel distributions grow at the rate of (some power of) $log n$ with $n \xrightarrow{} \infty$. Hence, median($N_i$)/log($I$) could serve as the final measure.


```{r}
library(readr)
read_rds("data/smart_harmony_musigma.rds")
```
```{r}
smart_meter10 %>%
  filter(customer_id %in% c(10017936)) %>%
  prob_plot("hour_day",
    "wknd_wday",
    response = "general_supply_kwh",
    plot_type = "quantile",
    symmetric = TRUE,
    quantile_prob = c(0.01, 0.1, 0.25, 0.5, 0.75, 0.9, 0.99)
  ) +
  scale_y_sqrt() +
  #ggtitle(" (b) Area quantile plot faceted by weekend-weekday") +
  ylab("electricity demand [KWh]") + xlab("hours of the day") + ggtitle("") + ylab("")+ 
  theme_minimal()
```


## Version 3 (old benchmark)

 3.3. For each $i \in \{1, 2, \dots, I\}$, the maximum pairwise distance could be chosen from  $\binom{I}{2}$ distances using $D_{i}$ = max($d_{jl}$)/$J$(max($d_{jl}$) - min($d_{jl}$)) $\forall j, l = {1, 2, \dots, J}$.

 4.3. Mean maximum pairwise distance (MMPD) over $i = {1, 2, \dots, I}$ is computed by
$MMPD = (1/I)\sum_{i=1}^{l}{D_{i}}$.


```{r}
library(readr)
read_rds("data/smart_harmony_n.rds")
```

```{r}
smart_meter10 %>%
  filter(customer_id %in% c(10017936)) %>%
  prob_plot("week_month",
    "wknd_wday",
    response = "general_supply_kwh",
    plot_type = "quantile",
    symmetric = TRUE,
    quantile_prob = c(0.01, 0.1, 0.25, 0.5, 0.75, 0.9, 0.99)
  ) +
  scale_y_sqrt() +
  #ggtitle(" (b) Area quantile plot faceted by weekend-weekday") +
  ylab("electricity demand [KWh]") + xlab("hours of the day") + ggtitle("") + ylab("")+ 
  theme_minimal()
```

 5. Steps 1 to 5 are repeated for every harmony pair and harmony pairs rearranged from highest to lowest MMPD (final measure). Harmony pair with higher MMPD would be more interesting as it would mean that the harmony pair exhibits more variations in distributions on an average between different levels of $C_2$.
